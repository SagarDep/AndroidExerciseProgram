package com.oubowu.exerciseprogram.customview.uc;import android.animation.Animator;import android.animation.AnimatorListenerAdapter;import android.animation.ValueAnimator;import android.content.Context;import android.support.v4.view.ViewCompat;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.View;import android.view.ViewTreeObserver;import android.widget.AbsListView;import android.widget.LinearLayout;import com.socks.library.KLog;/** * ClassName: * Author:oubowu * Fuction: * CreateDate:2016/2/9 19:47 * UpdateUser: * UpdateDate: */public class UcRefreshLayout extends LinearLayout {    // 隐藏的状态    private static final int HIDE = 0;    // 下拉刷新的状态    private static final int PULL_TO_REFRESH = 1;    // 松开刷新的状态    private static final int RELEASE_TO_REFRESH = 2;    // 正在刷新的状态    private static final int REFRESHING = 3;    private int mState = HIDE;    private int mHeaderViewHeight;    private View mContentView;    private float mMoveY;    private RecyclerView mRecyclerView;    private int mFirstPosition = -1, mLastPosition = -1;    private UcRerfreshHead mUcRerfreshHead;    private boolean mIntercept;    private ValueAnimator mPullUpAnimator;    private float mRatio;    public UcRefreshLayout(Context context, AttributeSet attrs) {        super(context, attrs);        init(context);    }    private void init(Context context) {        mUcRerfreshHead = new UcRerfreshHead(context);        addView(mUcRerfreshHead);        mUcRerfreshHead.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {            @Override            public void onGlobalLayout() {                mHeaderViewHeight = mUcRerfreshHead.getMeasuredHeight();                KLog.e("头部高度：" + -mHeaderViewHeight);                // 隐藏刷新头部                mUcRerfreshHead.setPadding(0, -mHeaderViewHeight, 0, 0);                mUcRerfreshHead.getViewTreeObserver().removeGlobalOnLayoutListener(this);            }        });    }    @Override    protected void onFinishInflate() {        super.onFinishInflate();        mContentView = getChildAt(1);        if (mContentView instanceof RecyclerView) {            mRecyclerView = (RecyclerView) mContentView;        }    }    @Override    public void setOrientation(int orientation) {        if (LinearLayout.VERTICAL != orientation) {            throw new IllegalArgumentException("This class only supports VERTICAL orientation.");        }        // Only support vertical orientation        super.setOrientation(orientation);    }    private float mDownY, mDistanceY;    private boolean mIsPullUp;    private boolean mIsPostDown;    @Override    public boolean dispatchTouchEvent(MotionEvent ev) {        mFirstPosition = ((LinearLayoutManager) mRecyclerView.getLayoutManager()).findFirstCompletelyVisibleItemPosition();//        KLog.e(mFirstPosition);//        if (mFirstPosition > 0) {//            // 位置大于0的时候不处理//            KLog.e("位置大于0的时候不处理");//            return dispatchTouchEvent(ev);//        }        if (mFirstPosition != 0) {            // 位置不为0时，不处理            mIsPostDown = false;            if (mPullUpAnimator == null || !mPullUpAnimator.isRunning()) {                KLog.e("开始列表自己滚动");                return super.dispatchTouchEvent(ev);            }        } else if (mLastPosition != mFirstPosition) {            // 处理头部的那一瞬间，坐标的基点为只一瞬间的y坐标            KLog.e("处理头部的那一瞬间，坐标的基点为只一瞬间的y坐标");            mDownY = ev.getY();        }        mLastPosition = mFirstPosition;        switch (ev.getAction()) {            case MotionEvent.ACTION_DOWN:                mDownY = ev.getY();                break;            case MotionEvent.ACTION_MOVE:                // 算出偏移量                mMoveY = ev.getY() - mDownY;                if (mMoveY > 0) {                    if (mUcRerfreshHead.isCombine()) {                        mState = RELEASE_TO_REFRESH;                    } else {                        mState = PULL_TO_REFRESH;                    }                    KLog.e("下拉，屏蔽事件自己处理");                    // 下拉，屏蔽事件自己处理                    mUcRerfreshHead.setPadding(0, (int) (-mHeaderViewHeight + mMoveY * 0.35f), 0, 0);                    // 记录下拉距离与头部高度的比值                    mRatio = mMoveY * 1.0f / 2.5f / mHeaderViewHeight;                    mUcRerfreshHead.performPull(mRatio);                    return true;                } else if (mMoveY < 0) {                    KLog.e("上拉，给列表处理");                    // 上滑                    if (!mIsPostDown) {                        ev.setAction(MotionEvent.ACTION_DOWN);                        mIsPostDown = true;                        KLog.e("呵呵呵呵 ACTION_DOWN");                    } else {                        ev.setAction(MotionEvent.ACTION_MOVE);                        KLog.e("呵呵呵呵 ACTION_MOVE");                    }                    return super.dispatchTouchEvent(ev);                }                break;            case MotionEvent.ACTION_UP:                mIsPostDown = false;                KLog.e("手指抬起");                if (mPullUpAnimator != null && mPullUpAnimator.isRunning()                        || mState == HIDE                        || mUcRerfreshHead.getPaddingTop() == -mHeaderViewHeight) {                    KLog.e("手指抬起不处理");                    return super.onTouchEvent(ev);                }                mPullUpAnimator = new ValueAnimator();                if (mState == RELEASE_TO_REFRESH) {                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), 0);                } else if (mState == PULL_TO_REFRESH) {                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), -mHeaderViewHeight);                }                mPullUpAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                    @Override                    public void onAnimationUpdate(ValueAnimator animation) {                        mUcRerfreshHead.setPadding(0, (Integer) animation.getAnimatedValue(), 0, 0);                        if (mState == RELEASE_TO_REFRESH) {                            mState = REFRESHING;                        } else if (mState == PULL_TO_REFRESH) {                            mUcRerfreshHead.performPull(mRatio * (1 - animation.getAnimatedFraction()));                        }                    }                });                mPullUpAnimator.addListener(new AnimatorListenerAdapter() {                    @Override                    public void onAnimationEnd(Animator animation) {                        super.onAnimationEnd(animation);                        if (mUcRerfreshHead.getPaddingTop() == 0 && mUcRerfreshHead.isCombine())                            mUcRerfreshHead.performLoading();                    }                });                mPullUpAnimator.setDuration(500);                mPullUpAnimator.start();                break;        }        return super.dispatchTouchEvent(ev);    }    /*@Override    public boolean dispatchTouchEvent(MotionEvent ev) {        mFirstPosition = ((LinearLayoutManager) mRecyclerView.getLayoutManager()).findFirstCompletelyVisibleItemPosition();        if (mFirstPosition != 0) {            // 位置不为0时，不处理            mIsPostDown = false;            if (mPullUpAnimator == null || !mPullUpAnimator.isRunning()) {//                KLog.e("开始列表自己滚动");                return super.dispatchTouchEvent(ev);            }        } else if (mLastPosition != mFirstPosition) {            // 处理头部的那一瞬间，坐标的基点为只一瞬间的y坐标            KLog.e("处理头部的那一瞬间，坐标的基点为只一瞬间的y坐标");            mDownY = ev.getY();        }        mLastPosition = mFirstPosition;        switch (ev.getAction()) {            case MotionEvent.ACTION_DOWN:                KLog.e("ACTION_DOWN");                // 位置为0的时候，按下屏幕时记录基准点                mDownY = ev.getY();                mIntercept = false;                mIsPostDown = false;                if (mUcRerfreshHead.getPaddingTop() == 0 && mState == REFRESHING) {                    // 如果头部显示并且当前状态为刷新                    mIsPullUp = true;                }                break;            case MotionEvent.ACTION_MOVE:                //  位置为0的时候，手指移动的时候                // 记录与按下点的距离                mMoveY = ev.getY() - mDownY;                if (mUcRerfreshHead.isLoading()) {                    mIsPullUp = true;                }                if (mMoveY > 0) {                    // 往下拉的时候，截断事件，自己处理头部                    KLog.e("下拉截断事件，自己处理头部");                    mIntercept = true;                } else if (mState == REFRESHING) {                    // 当前在刷新状态，截断事件，自己处理头部                    KLog.e("下拉截断事件，自己处理头部");                    mIntercept = true;                }                if (mPullUpAnimator != null && mPullUpAnimator.isRunning()) {                    return true;                }                if (!mIntercept) {                    // 不阻断，让列表自己滚动                    KLog.e("列表自己滚动");                    return super.dispatchTouchEvent(ev);                }                // 记录下拉距离与头部高度的比值                mRatio = mMoveY * 1.0f / 2.5f / mHeaderViewHeight;                KLog.e(mMoveY + " ; " + mRatio);                // 头部下拉动画                mUcRerfreshHead.performPull(mRatio);                if (mMoveY > 0) {                    // 下拉的时候                    if (mUcRerfreshHead.isCombine()) {                        // 头部组合效果完成后，头部状态为释放刷新状态                        mState = RELEASE_TO_REFRESH;                    } else {                        // 头部组合效果未完成，头部状态为下拉刷新状态                        mState = PULL_TO_REFRESH;                    }                    // 设置padding值，显示头部                    mUcRerfreshHead.setPadding(0, (int) (-mHeaderViewHeight + (int) (mMoveY * 0.5f)), 0, 0);                    KLog.e("下拉头部: " + (int) (-mHeaderViewHeight + (int) (mMoveY * 0.5f)));                    return true;                } else if (mMoveY < 0 && mState != HIDE) {                    // 上滑的时候，并且头部没有隐藏                    if (mIsPullUp) {                        mUcRerfreshHead.setPadding(0, (int) (mMoveY * 0.5f), 0, 0);                        mState = PULL_TO_REFRESH;                        KLog.e("刷新动画时上滑头部: " + -mHeaderViewHeight + (int) (mMoveY * 0.5f));                    } else {                        KLog.e("上滑头部");                        mUcRerfreshHead.setPadding(0, (int) (-mHeaderViewHeight), 0, 0);                        mState = HIDE;                    }                    if (mUcRerfreshHead.getPaddingTop() <= -mHeaderViewHeight) {                        mState = HIDE;                    }                    return true;                } else if (mMoveY < 0) {                    if (!mIsPostDown) {                        ev.setAction(MotionEvent.ACTION_DOWN);                        mIsPostDown = true;                        KLog.e("呵呵呵呵 ACTION_DOWN");                    } else {                        ev.setAction(MotionEvent.ACTION_MOVE);                        KLog.e("呵呵呵呵 ACTION_MOVE");                    }                    return super.dispatchTouchEvent(ev);                }                //break;            case MotionEvent.ACTION_UP:                mIsPostDown = false;                mIsPullUp = false;                KLog.e("手指抬起");                if (mPullUpAnimator != null && mPullUpAnimator.isRunning()                        || mState == HIDE                        || mUcRerfreshHead.getPaddingTop() == -mHeaderViewHeight) {                    KLog.e("手指抬起不处理");                    return super.onTouchEvent(ev);                }                mPullUpAnimator = new ValueAnimator();                if (mState == RELEASE_TO_REFRESH || mState == REFRESHING) {                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), 0);                } else if (mState == PULL_TO_REFRESH) {                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), -mHeaderViewHeight);                }                mPullUpAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                    @Override                    public void onAnimationUpdate(ValueAnimator animation) {                        mUcRerfreshHead.setPadding(0, (Integer) animation.getAnimatedValue(), 0, 0);                        if (mState == RELEASE_TO_REFRESH) {                            mState = REFRESHING;                        } else if (mState == PULL_TO_REFRESH) {                            mUcRerfreshHead.performPull(mRatio * (1 - animation.getAnimatedFraction()));                        }                    }                });                mPullUpAnimator.addListener(new AnimatorListenerAdapter() {                    @Override                    public void onAnimationEnd(Animator animation) {                        super.onAnimationEnd(animation);                        if (mUcRerfreshHead.getPaddingTop() == 0 && mUcRerfreshHead.isCombine())                            mUcRerfreshHead.performLoading();                    }                });                mPullUpAnimator.setDuration(500);                mPullUpAnimator.start();                break;        }        return super.dispatchTouchEvent(ev);    }*///    @Override//    public boolean dispatchTouchEvent(MotionEvent ev) {////        mFirstPosition = ((LinearLayoutManager) mRecyclerView.getLayoutManager()).findFirstCompletelyVisibleItemPosition();////        if (mFirstPosition != 0) {//            // 位置不为0时，不处理//            mIsPostDown = false;//            if (mPullUpAnimator == null || !mPullUpAnimator.isRunning()) {////                KLog.e("开始列表自己滚动");//                return super.dispatchTouchEvent(ev);//            }//        } else if (mLastPosition != mFirstPosition) {//            // 处理头部的那一瞬间，坐标的基点为只一瞬间的y坐标//            mDownY = ev.getY();//        }////        mLastPosition = mFirstPosition;////        switch (ev.getAction()) {//            case MotionEvent.ACTION_DOWN://                KLog.e("ACTION_DOWN");//                // 位置为0的时候，按下屏幕时记录基准点//                mDownY = ev.getY();//                mIntercept = false;//                mIsPostDown = false;//                if (mUcRerfreshHead.getPaddingTop() == 0 && mState == REFRESHING) {//                    // 如果头部显示并且当前状态为刷新//                    mIsPullUp = true;//                    KLog.e("mIsPullUp = true");//                }//                break;//            case MotionEvent.ACTION_MOVE:////                mMoveY = ev.getY() - mDownY;////                if (mFirstPosition == 0 && mMoveY > 0 && mUcRerfreshHead.getPaddingTop() <= 0) {//                    // 截断事件，自己处理头部//                    KLog.e("下拉截断事件，自己处理头部");//                    mIntercept = true;//                } else if (mState == REFRESHING) {//                    KLog.e("下拉截断事件，自己处理头部");//                    mIntercept = true;//                }////                if (!mIntercept || mFirstPosition != 0) {//                    KLog.e("列表自己滚动");//                    return super.dispatchTouchEvent(ev);//                }////                if (mUcRerfreshHead.isLoading()) {//                    mIsPullUp = true;//                }////                final float mRatio = mMoveY * 1.0f / 2.5f / mHeaderViewHeight;//                mUcRerfreshHead.performPull(mRatio);//                if (mMoveY > 0) {//                    if (mRatio >= 1) {//                        mState = RELEASE_TO_REFRESH;//                    } else {//                        mState = PULL_TO_REFRESH;//                    }//                    mUcRerfreshHead.setPadding(0, (int) (-mHeaderViewHeight + (int) (mMoveY * 0.5f)), 0, 0);//                    KLog.e("下拉头部: " + (int) (-mHeaderViewHeight + (int) (mMoveY * 0.5f)));//                    return true;//                } else if (mMoveY < 0 && mState != HIDE) {//                    /*if (mIsPullUp) {//                        mUcRerfreshHead.setPadding(0, -mHeaderViewHeight + (int) (mMoveY * 0.5f), 0, 0);//                        mState = PULL_TO_REFRESH;//                        KLog.e("刷新动画时上滑头部: " + -mHeaderViewHeight + (int) (mMoveY * 0.5f));//                    } else {//                        KLog.e("上滑头部");//                        mUcRerfreshHead.setPadding(0, (int) (-mHeaderViewHeight), 0, 0);//                        mState = HIDE;//                    }*///////                    if (mUcRerfreshHead.getPaddingTop() <= -mHeaderViewHeight) {//                        mState = HIDE;//                    }//                    return true;//                } else if (mMoveY < 0) {//                    if (!mIsPostDown) {//                        ev.setAction(MotionEvent.ACTION_DOWN);//                        mIsPostDown = true;//                        KLog.e("呵呵呵呵 ACTION_DOWN");//                    } else {//                        ev.setAction(MotionEvent.ACTION_MOVE);//                        KLog.e("呵呵呵呵 ACTION_MOVE");//                    }//                    return super.dispatchTouchEvent(ev);//                }//                //break;//            case MotionEvent.ACTION_UP://                mIsPostDown = false;//                mIsPullUp = false;//                KLog.e("手指抬起");//                if (mPullUpAnimator != null && mPullUpAnimator.isRunning()//                        || mState == HIDE//                        || mUcRerfreshHead.getPaddingTop() == -mUcRerfreshHead.getPaddingTop()) {//                    KLog.e("手指抬起不处理");//                    return super.onTouchEvent(ev);//                }//                mPullUpAnimator = new ValueAnimator();//                if (mState == RELEASE_TO_REFRESH || mState == REFRESHING) {//                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), 0);//                } else if (mState == PULL_TO_REFRESH) {//                    mPullUpAnimator.setIntValues(mUcRerfreshHead.getPaddingTop(), -mHeaderViewHeight);//                }//                mPullUpAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {//                    @Override//                    public void onAnimationUpdate(ValueAnimator animation) {//                        mUcRerfreshHead.setPadding(0, (Integer) animation.getAnimatedValue(), 0, 0);//                        mState = REFRESHING;//                    }//                });//                mPullUpAnimator.addListener(new AnimatorListenerAdapter() {//                    @Override//                    public void onAnimationEnd(Animator animation) {//                        super.onAnimationEnd(animation);//                        if (mUcRerfreshHead.getPaddingTop() == 0)//                            mUcRerfreshHead.performLoading();//                    }//                });//                mPullUpAnimator.setDuration(500);//                mPullUpAnimator.start();//                break;//        }////        return super.dispatchTouchEvent(ev);//    }    private String getActionStr(int action) {        switch (action) {            case MotionEvent.ACTION_DOWN:                return "ACTION_DOWN";            case MotionEvent.ACTION_MOVE:                return "ACTION_MOVE";            case MotionEvent.ACTION_UP:                return "ACTION_UP";            case MotionEvent.ACTION_CANCEL:                return "ACTION_CANCEL";        }        return "null";    }    @Override    public void requestDisallowInterceptTouchEvent(boolean b) {        // if this is a List < L or another view that doesn't support nested        // scrolling, ignore this request so that the vertical scroll event        // isn't stolen        if ((android.os.Build.VERSION.SDK_INT < 21 && mContentView instanceof AbsListView)                || (mContentView != null && !ViewCompat.isNestedScrollingEnabled(mContentView))) {            // Nope.        } else {            super.requestDisallowInterceptTouchEvent(b);        }    }}